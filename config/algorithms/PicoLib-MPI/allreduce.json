{
  "recursive_doubling_over": {
    "desc": "Libswing external recursive doubling algorithm. This algorithm is used for small to medium messages",
    "version": "1.0.0",
    "tags": [
      "recursive_doubling",
      "small_sizes",
      "medium_sizes"
    ]
  },
  "ring_over": {
    "desc": "Libswing external ring algorithm. Not to be used if `count`<`comm_sz`. This algorithm is used for large messages",
    "version": "1.0.0",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "ring",
      "large_sizes"
    ]
  },
  "rabenseifner_over": {
    "desc": "Libswing external Rabenseifner algorithm. Not to be used if `count`<`comm_sz` and for non commutative `op`. This algorithm is used for medium to large messages",
    "version": "1.0.0",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      }
    ],
    "tags": [
      "rabenseifner",
      "medium_sizes",
      "large_sizes"
    ]
  },
  "swing_lat_over": {
    "desc": "Libswing external swing latency optimal algorithm. This algorithm is used for small to medium messages",
    "version": "1.0.0",
    "tags": [
      "swing_lat",
      "swing",
      "latency_optimal"
    ]
  },
  "swing_bdw_static_over": {
    "desc": "Libswing external swing bandwidth optimal algorithm. Not to be used if `count`<`comm_sz`. Works only with power of 2 processes, less or equal to 256. This version utilizes static bitmaps reordered to be contigous. This algorithm is used for medium to large messages",
    "version": "1.0.0",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      },
      {
        "key": "comm_sz",
        "conditions": [
          {
            "operator": "is_power_of_two",
            "value": true
          },
          {
            "operator": "<=",
            "value": 256
          }
        ]
      }
    ],
    "tags": [
      "swing_bdw_static",
      "swing",
      "bandwidth_optimal",
      "static",
      "suboptimal"
    ]
  },
  "swing_bdw_remap_over": {
    "desc": "Libswing external swing bandwidth optimal algorithm. Not to be used if `count`<`comm_sz`. Works only with power of 2 processes. This version remaps rank to allow the sending of contiguous buffers.",
    "version": "1.0.0",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      },
      {
        "key": "comm_sz",
        "conditions": [
          {
            "operator": "is_power_of_two",
            "value": true
          }
        ]
      }
    ],
    "tags": [
      "swing_bdw_remap",
      "swing",
      "bandwidth_optimal",
      "remap"
    ]
  },
  "swing_bdw_remap_segmented_over": {
    "desc": "Libswing external swing bandwidth optimal algorithm. Not to be used if `count`<`comm_sz`. Works only with power of 2 processes. This version remaps rank to allow the sending of contiguous buffers. It segments the message into segments of size `segsize  = count / comm_sz` ",
    "version": "1.0.0",
    "constraints": [
      {
        "key": "count",
        "conditions": [
          {
            "operator": ">=",
            "value": "comm_sz"
          }
        ]
      },
      {
        "key": "comm_sz",
        "conditions": [
          {
            "operator": "is_power_of_two",
            "value": true
          }
        ]
      }
    ],
    "tags": [
      "swing_bdw_remap_segmented",
      "swing",
      "is_segmented",
      "bandwidth_optimal",
      "remap"
    ]
  }
}
